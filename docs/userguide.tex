\documentclass[a4paper]{article}
\usepackage{txfonts}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{supertabular}
\usepackage{array}
\usepackage[colorlinks,final]{hyperref}

\newcommand{\VERNO}{0.1.0 }
\newcommand{\var}[1]{\texttt{#1}}


\textheight 9.2in 
\textwidth 6.2in
\oddsidemargin 0pt
\topmargin -40pt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{GANDALF v\VERNO userguide}
\author{David Hubber \& Giovanni Rosotti}

\maketitle
\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of code}
GANDALF is a new SPH and N-body code written in C++ and Python.  Although partly based on some of the algorithms and code structures used in SEREN (Hubber et al. 2011), it has been written from scratch and contains many new features and optimisations which significantly improve the speed, functionality and usability of the code.  It has been written for several purposes.
\begin{itemize}
\item GANDALF has been written with a fully object-oriented philosophy in C++.  This is to improve the maintainability of the code and also to allow the code to be easily extended in the future with as little disruption to the original code-base as possible.
\item GANDALF can be run in three different modes; as a standard C++ executable run from the command line, run from a python script or run inside an interactive python environment.  Both the script and interactive python modes include a graphical output that can be used to visualise previously run simulations, or to interactively visualise simulations as they are run on-the-fly.
\item GANDALF contains a variety of SPH algorithms such as conservative 'grad-h' SPH (Springel \& Hernquist 2002, Price \& Monaghan 2004), Saitoh \& Makino (2013) SPH and Godunov SPH (Inutsuka 2002).
\item The N-body component of GANDALF contains a variety of common integration schemes such as 4th/6th-order Hermite with time-symmetric integration.
\item GANDALF can generate initial conditions at run-time, as opposed to SEREN where the initial conditions had to be prepared a priori to running the simulation.  The initial conditions may either be hard-coded into the C++ code, or set-up via a python script using numpy arrays.
\item GANDALF uses additional parameters to switch on various physics options, as well as requiring them to be activated in the Makefile.  In comparison, SEREN controlled physics options exclusively in the Makefile.  Therefore, GANDALF need not be re-compiled everytime a different setting is required.
\end{itemize}

Since GANDALF is currently in the beta-testing phase, it would be very helpful for the authors if new users could provide feedback of any problems with the code, or with any suggestions for improvements of existing features.  Ideally, users would submit bug reports to the GANDALF github page (https://github.com/gandalfcode/gandalf/issues) since other users can see that a bug has been identified before sending identical bug reports.

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation} \label{S:INSTALL}
In order to use all features in GANDALF, the following programs and libraries must be installed : 
\begin{itemize}
\item C++ compiler; at present, only gcc/g++ has been tested with the code
\item Python 2.7
\item swig compatible with python 2.7
\item matplotlib compatible with python 2.7
\item numpy
\item scipy
\item f2py compatible with python 2.7 (normally included in numpy)
\item Fortran compiler
\end{itemize}

If you are not interested in the Python library, you need only a C++ compiler. To reduce the number of needed libraries, we ship together with GANDALF the following packages:
\begin{itemize}
\item pyparsing
\item cmd2
%\item ffmpeg (for generating movies automatically)
\end{itemize}
We thank the authors for writing these softwares and release them under the MIT license.


\subsection{Linux}
All of these programs/libraries can be found in most standard Linux installations, and if not, will be available to download from most package managers (e.g. apt-get, yum, pacman).  

\subsection{Mac OS X} 
For Mac users, all programs can be installed with either fink, MacPorts or homebrew.  It is preferable that all (except the Fortran compiler) are downloaded with just the one package manager in order to ensure they are compatible and function together correctly. Other options for installation are the Anaconda or Enthought Python distributions. A good reference which compares the available possibilities is the \href{http://python4astronomers.github.io/installation/recommended_options.html}{Python4Astronomers website}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Command-line code compilation}

To compile GANDALF only as a C++ executable to be run from the command line without visualisation via the python program, first set the chosen C++ compiler in the Makefile and type \\
\newline
\noindent \var{make executable} \\

\noindent The code is compiled and linked with the chosen C++ compiler and all python components are ignored.  If you do not have python installed on your system, or are having trouble getting the python components to function correctly, then the C++ executable can still be compiled and run stand-alone.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python code compilation}
To compile all code elements including the python components, then complete the following steps : 
\begin{itemize}

\item Install all python-related programs listed in Section \ref{S:INSTALL}

\begin{itemize}
\item For Linux machines, python is usually installed by default.  The additional python libraries should be easily installed using either the main package manager,  {\var pip} or {\var easy\_install}.
\item For Mac OS X, python is installed by default.  However, it does not have directly compatible versions of all the required libraries.  Therefore, it is required to install an additional version of python 2.7 using a 3rd party package manager like fink, Macports or homebrew.
\end{itemize}

\item Add the location of the folder containing the main GANDALF directory to the \var{PYTHONPATH} environment variable.  If you are using bash or related shells, then add the line \\
\newline
\noindent \var{export PYTHONPATH=XXX/YYY:\$PYTHONPATH} \\

\noindent to your \var{.bashrc} (or \var{.bash\_profile} on a Mac) script where \var{XXX/YYY/gandalf} is the absolute path of the GANDALF directory (note that you must not include ``gandalf'' in the folder name!). If you are using csh, tcsh or related shells, then add \\
\newline
\noindent \var{setenv PYTHONPATH ``XXX/YYY:\$PYTHONPATH''} \\

\noindent to your relevant shell configuration file. Remember that you have to close and reopen the shell for this change to take effect, or to \var{source} the shell configuration file.

\item Set the required version of python and f2py in your Makefile (See Section \ref{S:MAKEFILE}).  Since operating systems usually have more than one version of python installed, it is important to ensure that \var{make} uses the correct version when compiling the code.  These are set using the \var{PYTHON} and \var{F2PY} variables in the Makefile.

Also, \var{make} requires the location of the python and numpy libraries.  In most cases, \var{make} will be able to locate these libraries automatically (see description of Makefile options).  However, if there is a problem, or you wish to use an alternative version of these libraries installed elsewhere on your system, then these can be set by the \var{PYLIB} and \var{NUMPY} variables in the Makefile.  


\item Finally, to compile all components of the code, including the python libraries with swig, type \\
\newline
\noindent \var{make} or \var{make all} \\

\end{itemize}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic usage}
GANDALF can be run in three principle modes.  
\begin{itemize} 
\item Command-line mode, where the code is run as a C++ executable via the command line with a parameters file that selects which code options are used4 (similar to SEREN), 
\item via a python script where the code is run in a python environment with various plotting options available as well as running the code, 
\item in interactive mode where all the code and plotting options can be run directly by typing them into an interactive python shell.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Command-line mode}

\noindent To run a simulation with the C++ executable on the command line, type : \\
\newline
\var{./gandalf PARAMSFILE} \\
\newline
where PARAMSFILE is the name of the parameters file for that simulation.  If that parameters file does not exist in the current directory, or contains invalid parameter options, then the program will quit citing an error message.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Running python scripts}

\noindent Any python script using the GANDALF python API can be run directly from the command-line as any regular python script.  To run the script PYTHONSCRIPT.py, type \\
\newline
\var{python PYTHONSCRIPT.py} \\
\newline
or, depending on the default version of python on your system (e.g. installing matplotlib with fink on Mac OS X), \\
\newline
\var{python2.7 PYTHONSCRIPT.py} \\
\newline
The code will remain inside the python environment until the script is fully executed.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interactive mode}

\noindent To open the interactive viewer, type : \\
\newline
\var{python analysis/gandalf\_interpreter.py} \\
\newline
or, depending on the default version of python on your system (e.g. installing matplotlib with fink on Mac OS X), \\
\newline
\var{python2.7 analysis/gandalf\_interpreter.py} \\
\newline
\noindent The code should open with a splash screen containing the code title followed by a command prompt of the form '\var{gandalf >'}'.  To run a simulation defined by a parameter file, then type \\
\newline
\var{newsim PARAMSFILE} \\
\newline
\noindent and then \\
\newline
\var{run} \\
\newline
\noindent The current simulation can be plotted at any point by using simple commands such as, for example, \\
\newline
\var{plot x y} \\
\newline
\noindent For a list on available commands, type \var{help} in the command line.  For more detailed information on the functionality of a particular command, type \var{help command}.  For more information on interactive python commands, see Section \ref{S:PYTHONSCRIPT}.

\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Makefile options} \label{S:MAKEFILE}
The GANDALF Makefile is used to select options which are used to compile the code with.  If the user wishes to change any compile-time options, the code must be recompiled from scratch by typing {\var make clean} and then \var{make}.  For users of SEREN, the GANDALF Makefile has been simplified with many options either not present (since various specialist algorithms have not been implemented) or have been transfered to the parameters file.  This has been done in order to make it less likely that the wrong Makefile options are used in simulations, and also to stop the need to recompile the code completely so often when using slightly different options.

\begin{itemize}

\item CPP : C++ compiler (only gcc/g++ set-up at present) \\
\begin{tabular}{ll}
g++ & : GCC C++ compiler \\
clang & : CLANG compiler
\end{tabular}

\item PYTHON : name of python command-line executable (e.g. python, python2.7)

\item F2PY : f2py executable name (e.g. f2py,f2py2.7)

\item COMPILER\_MODE : Set compiler flags for production or debug runs \\
\begin{tabular}{ll}
DEBUG & : Set all debug compiler options, including flags to use gdb debugger and full warning output (-Wall) \\
STANDARD & : Standard optimisation options (-O3) \\
FAST & : -O3 + fast flag options.  Uses 'potentially unsafe' fast maths optimisation.  
\end{tabular}

\item PRECISION : Floating point precision \\
\begin{tabular}{ll}
SINGLE & : 32-bit precision floating point variables \\
DOUBLE & : 64-bit precision floating point variables
\end{tabular}

\item OPENMP : Activate OpenMP directives during compilation (0 or 1)

\item OUTPUT\_LEVEL : Amount of output produced by code \\
\begin{tabular}{ll}
0 & : No additional output \\
1 & : Minimal output of main-loop routines \\
2 & : Code routine marker output for all steps
\end{tabular}

\item DEBUG\_LEVEL : Amount of extra debug checking done by code \\
\begin{tabular}{ll}
0 & : No extra debugging computations and output \\
1 & : Activate assert debug statements in code \\
2 & : Activate extra (expensive) debugging computations in code
\end{tabular}

\item PYLIB : Path to directory that includes prefered python libraries.  If left blank, {\var make} will use python routines to locate the libraries automatically.

\item NUMPY : Path to directory that includes prefered numpy libraries.  Ase with PYLIB, If left blank, {\var make} will use python routines to locate the library locations automatically.

\end{itemize}

\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parameter options}

\noindent With the exception of a few compiled-time options that are selected in the Makefile, all physics and code feature options are controlled from the parameters file, including the dimensionality, simulation type and SPH options.  We list here all possible parameters, including all possible options for those parameters with a limited choice.  We note that a parameters file need not contain a value for each parameter, in which case the default value is taken.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Main simulation parameters}

\begin{itemize}

\item \var{ndim} : Simulation dimensionality ($1$, $2$ or $3$)

\item \var{sim} : Simulation type \vspace{0.1cm} \\
\begin{tabular}{ll}
godunov\_sph      & = Godunov SPH algorithm (Inutsuka 2002) \\
nbody             & = N-body only algorithm \\
sph               & = SPH (+ N-body) algorithn 
\end{tabular}

\item \var{sph} : SPH algorithm (when using \var{sim = sph}) \\
\begin{tabular}{ll}
gradh    & = Conservative 'grad-h' SPH \\
sm2012   & = Saitoh \& Makino (2012) SPH
\end{tabular}

\item \var{nbody} : Main N-body integration algorithm \\
\begin{tabular}{ll}
lfkdk        & = 2nd-order Leapfrog kick-drift-kick \\
hermite4     & = 4th-order Hermite scheme \\
hermite4ts   & = Time-symmetric 4th-order Hermite scheme
\end{tabular}

\item \var{ic} : Simulation initial conditions \vspace{0.1cm} \\
\begin{tabular}{ll}
file              & = Load initial conditions from external file \\
binary            & = Simple binary star test \\
bb                & = Boss-Bodenheimer (1979) test \\
box               & = Create a uniform box of gas \\
cdiscontinuity    & = Contact discontinuity test \\
khi               & = Kelvin-Helmholtz instability test \\
noh               & = Noh problem initial conditions \\
plummer           & = Plummer sphere test \\
quadruple         & = Simple hierarchical quadruple test \\
sedov             & = Sedov blast-wave test \\
shearflow         & = Shear flow test \\
shocktube         & = Shocktube test \\
soundwave         & = 1D soundwave perturbation \\
sphere            & = Uniform density sphere \\
python            & = Generate initial conditions from python
\end{tabular}

\item \var{run\_id}  : Simulation run id string

\item \var{in\_file} : Input filename (when \var{ic = file})

\item \var{in\_file\_form} : Format of initial conditions file
                      (ascii)

\item \var{out\_file\_form} : Format of outputted snapshot files
                      (ascii)

\item \var{tend} : Termination time of the simulation (given in {\var tunit}s)

\item \var{dt\_snap} : Snapshot time interval (given in {\var tunit}s)

\item \var{tfirstsnap} : Time of first snapshot (given in {\var tunit}s)

\item \var{Nstepsmax} : Maximum no. of steps in simulation before termination

\item \var{noutputstep} : Frequency of screen output (in units of integer steps)

%\item \var{ndiagstep} : No. of complete block steps between diagnostic output

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unit parameters}

\begin{itemize}
\item \var{dimensionless} : Are all particle quantities dimensionless? ($0$ or $1$)

\item \var{routunit} : Position unit \vspace{0.1cm} \\
\begin{tabular}{ll}
pc/kpc/mpc & = parsec/kiloparsec/megaparsec \\
au         & = astronomical unit \\
r\_sun     & = Solar radius \\
r\_earth   & = Earth radius \\
cm/m/km    & = centimetre/metre/kilometre
\end{tabular}

\item \var{moutunit} : Mass unit \vspace{0.1cm} \\
\begin{tabular}{ll}
m\_sun          & = Solar mass \\
m\_jup/m\_earth & = Jupiter mass/Earth mass \\
g/kg            & = gram/kilogram
\end{tabular}


\item \var{toutunit} : Time unit \\
\begin{tabular}{ll}
yr/myr/gyr & = year/megayear/gigayear \\
day        & = day \\
sec        & = second
\end{tabular}

\item \var{voutunit} : Velocity unit \\
\begin{tabular}{ll}
cm\_s/m\_s/km\_s & = centimetres/metres/kilometres per second \\
au\_yr           & = astronomical units per year
\end{tabular}

\item \var{aoutunit} : Acceleration unit \\
\begin{tabular}{ll}
cm\_s2/m\_s2/km\_s2 & = cm/m/km per second squared \\
au\_yr2             & = astronomical units per year squared
\end{tabular}

\item \var{rhooutunit} : Density unit \\
\begin{tabular}{ll}
m\_sun\_pc3 & = Solar masses per parsec cubed \\
kg\_m3      & = kilogrammes per metre cubed \\
g\_cm3      & = grammes per centimetre cubed
\end{tabular}

\item \var{sigmaunit} : Column/surface density unit \\
\begin{tabular}{ll}
kg\_m2      & = kilogrammes per meter squared
\end{tabular}

\item \var{pressoutunit} : Pressure unit \\
\begin{tabular}{ll}
Pa    & = pascals/newtons per square metre \\
bar   & = ???
\end{tabular}

\item \var{foutunit} : Force unit \\
\begin{tabular}{ll}
N    & = newtons \\
dyn  & = dynes
\end{tabular}

\item \var{Eoutunit} : Energy unit \\
\begin{tabular}{ll}
J/GJ      & = joules/gigajoules \\
erg       & = ergs \\
10\^40erg & = $10^{40}$ ergs
\end{tabular}

\item \var{momoutunit} : Momentum unit \\
\begin{tabular}{ll}
m\_sunkm\_s  & = Solar masses kilometres per second \\
m\_sunau\_yr & = Solar masses A.U. per year \\
kgm\_s       & = Kilogram metres per second \\
gcm\_s       & = Gram centimetres per second
\end{tabular}

\item \var{angmomoutunit} : Angular momentum unit \\
\begin{tabular}{ll}
m\_sunkm2\_s  & = Solar masses kilometres squared per second \\
m\_sunau2\_yr & = Solar masses A.U. squared per year \\
kgm2\_s       & = Kilogram metres squared per second \\
gcm2\_s       & = Gram centimetres squared per second
\end{tabular}

\item \var{angveloutunit} : Angular velocity unit \\
\begin{tabular}{ll}
rad\_s & = Radians per second
\end{tabular}

%\item \var{dmdtoutunit} : Mass (accretion) rate unit \\
%\begin{itemize}{ll}
%m\_sun\_myr  & = Solar masses per megayear \\
%m\_sun\_yr   & = Solar masses per year \\
%kg\_s        & = kilogrammes per second \\
%g\_s         & = grammes per second
%\end{tabular}

%\item \var{Loutunit} : Luminosity unit

%\item \var{kappaoutunit} : Volume opacity unit

%\item \var{Bunit} : Magnetic field unit

%\item \var{Qunit} : Charge unit

\item \var{uunit} : Specific energy unit \\
\begin{tabular}{ll}
J\_kg  & = Joules per kilogram \\
erg\_g & = ergs per gram
\end{tabular}

%\item \var{Jcurunit} : Current density unit

\item \var{dudtunit} : Heating rate unit \\
\begin{tabular}{ll}
J\_kg\_s  & = Joules per kilogram per second \\
erg\_g\_s & = ergs per gram per second
\end{tabular}

\item \var{tempunit} : Temperature unit \\
\begin{tabular}{ll}
K & = Kelvin
\end{tabular}

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Integration and timestep parameters}

\begin{itemize}

\item \var{accel\_mult} : Acceleration timestep multiplier

\item \var{courant\_mult} : Courant timestep multiplier

\item \var{nbody\_mult} : N-body timestep multiplier

\item \var{subsys\_mult} : Sub-system N-body timestep multiplier

\item \var{Nlevels} : No. of initial timestep levels

\item \var{level\_diff\_max} : Maximum allowed SPH neighbour timestep difference

\item \var{sph\_single\_timestep} : Constrain all SPH particles to a single timestep level 

\item \var{nbody\_single\_timestep} : Constrain all N-body particles to a single timestep level 


\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{SPH parameters}

\begin{itemize}

\item \var{sph\_integration} : SPH particle integration scheme \\
\begin{tabular}{ll}
lfkdk   & = 2nd-order Leapfrog kick-drift-kick
\end{tabular}

\item \var{kernel} : SPH kernel function \\
\begin{tabular}{ll}
m4        & = M4 Cubic spline kernel \\
quintic   & = Quintic spline kernel \\
gaussuan  & = Gaussian kernel (truncated at 3h)
\end{tabular}

\item \var{tabulatedkernel} : Tabulate kernel function  ($1$ or $0$)

\item \var{h\_fac}     : Particles-per-smoothing length factor (eta in papers)

\item \var{h\_converge} : Smoothing length iteration convergence tolerance

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hydrodynamical parameters}

\begin{itemize}
\item \var{hydro\_forces} : Compute hydro forces?  ($1$ or $0$)

\item \var{gas\_eos} : Gas particles equation-of-state \\
\begin{tabular}{ll}
energy\_eqn & = Solve energy equation \\
isothermal  & = Isothermal EOS \\
barotropic  & = Barotropic EOS (i.e. for mimicing isothermal + adiabatic phase during protostellar collapse)
\end{tabular}

%\item \var{cooling\_law} : Cooling law for gas particles (only applicable if solving the energy equation) \\
%\begin{tabular}{ll}
%none    & = No cooling \\
%linear1 & = Simple linear cooling law
%\end{tabular}

\item \var{energy\_integration} : Energy integration scheme (only applicable if solving the energy equation) \\
\begin{tabular}{ll}
PEC         & = Explicit integration using predict-correct-evaluate scheme
\end{tabular}

\item \var{energy\_mult} : Explicit energy integration timestep multiplier

\item \var{gamma\_eos} : Ratio of specific heats for gas

\item \var{temp0} : (Isothermal) temperature (isothermal or barotropic EOS)

\item \var{mu\_bar}    : Mean gas particle mass (in units of hydrogen mass)

\item \var{rho\_bary} : Adiabatic density turnover in barotropic EOS (in g/cm\^3)

\item \var{eta\_eos}   : Polytropic exponent (for barotropic EOS)

%\item \var{Acool} : Simple cooling rate factor

%\item \var{u\_eq} : Equilibrium internal energy (for simple cooling law)


\item \var{avisc} : Artificial viscosity options \\
\begin{tabular}{ll}
none  & = No artificial viscosity \\
mon97 & = Monaghan (1997) viscosity
\end{tabular}

\item \var{acond} : Artificial conductivity options \\
\begin{tabular}{ll}
none        & = No artificial conductivity \\
price2008   & = Price (2008) conductivity \\
wadsley2008 & = Wadsley et al. (2008) conductivity
\end{tabular}

\item \var{alpha\_visc} : (Maximum) value of alpha viscosity parameter

\item \var{beta\_visc} : Value of beta viscosity as a multiple of alpha


\item \var{riemann\_solver} : Riemann solver to be used in Godunov SPH \\
\begin{tabular}{ll}
exact  & = Exact Riemann solver (Toro 19??) \\
hllc   & = HLLC approximate Riemann Solver (????)
\end{tabular}

\item \var{riemann\_order} : Order of Riemann solver \\
\begin{tabular}{ll}
1  & = 1st-order Riemann solver (i.e. Godunov's original method) \\
2  & = 2nd-order Riemann solver (i.e. 2nd-order MUSCL-type reconstruction)
\end{tabular}

\item \var{slope\_limiter} : Slope limiter for second-order Riemann solver \\
\begin{tabular}{ll}
????     & = ???? \\
\end{tabular}


%\item \var{td\_avisc} : Use time-dependent viscosity? (\var{.true.} or \var{.false.})

%\item \var{alpha\_min\_visc} : Minimum value of alpha for time-dependent viscosity

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Gravitational parameters}

\begin{itemize}

\item \var{self\_gravity} : Compute gravitational forces?   ($1$ or $0$)

%\item \var{grav\_kernel} : 

%\item \var{meanh\_gravity} : Use mean-smoothing length for gravitational forces? (\var{.true.} or \var{.false.})

%\item \var{thetamaxsqd} : Gravity tree opening angle (squared)

%\item \var{external\_force}   : Add an external gravitational field

%\item \var{ggrav}             : External gravitational acceleration


\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Neighbour searching and tree parameters}

\begin{itemize}

\item \var{neib\_search} : Neighbour searching algorithm \vspace{0.1cm} \\
\begin{tabular}{ll}
bruteforce & = Brute-force (i.e. summation over all particles) \\
grid       & = Grid with uniform spacing (N.B. doesn't currently work with self-gravity) \\
binarytree & = Balanced binary tree
\end{tabular}

\item \var{gravity\_mac} : Gravity-tree cell-opening criteria (N.B. always defulats to geometric for now) \vspace{0.1cm} \\
\begin{tabular} {ll}
geometric & = Standard Barnes-Hut geomtric opening angle criterion
\end{tabular}

\item \var{multipole} : Multipole expansion for tree-gravity \vspace{0.1cm} \\
\begin{tabular} {ll}
monopole & = Monopole-only terms for cell gravity \\
quadrupole & = Include quadrupole moment terms for cell gravity
\end{tabular}

\item \var{Nleafmax} : Maximum no. of particles allowed in tree leaf cell

\item \var{thetamaxsqd} : Maximum tree opening angle (squared)

\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{N-body parameters}

\begin{itemize}

\item \var{sub\_systems} : Identify and integrate sub-systems separately?

\item \var{sub\_system\_integration} : Main N-body integration algorithm \\
\begin{tabular}{ll}
lfkdk        & = 2nd-order Leapfrog kick-drift-kick \\
hermite4     & = 4th-order Hermite scheme \\
hermite4ts   & = Time-symmetric 4th-order Hermite scheme
\end{tabular}

\item \var{Npec} : No. of P(EC)\^n iterations in time-symmetric scheme (if non time-symmetric scheme is used, automatically sets to $1$)

\item \var{nbody\_softening} : Use SPH kernel-softening between star particles? ($1$ or $0$)

\item \var{gpefrac} : Maximum fraction of total gravitational potential energy from external sources to allow sub-system.

\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sink particle parameters}

\begin{itemize}

\item \var{sink\_particles}   : Do stars/sinks accrete?  ($0$ or $1$)

\item \var{create\_sinks}     : Create new sink particles?  ($0$ or $1$)

\item \var{smooth\_accretion} : Use smooth accretion?  ($0$ or $1$)

\item \var{rho\_sink}         : Sink particle creation density

\item \var{sink\_radius}      : Sink particle radius (in units of smoothing length)

\item \var{alpha\_ss}         : Sunyaev-Shakura alpha

\item \var{smooth\_accrete\_frac} : Smooth accretion instantaneous accretion mass frac.

\item \var{smooth\_accrete\_dt} : Smooth accretion instantaneous accretion timestep frac.

\item \var{sink\_radius\_mode} : How to calculate new sink radius \\
\begin{tabular}{ll}
hmult   &= sink radius a multiple of SPH particle smoothing length
\end{tabular}


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boundary parameters}

\begin{itemize}

\item \var{x\_boundary\_lhs} : Boundary conditions for LHS of x-dimension
\item \var{x\_boundary\_rhs} : Boundary conditions for RHS of x-dimension
\item \var{y\_boundary\_lhs} : Boundary conditions for LHS of y-dimension
\item \var{y\_boundary\_rhs} : Boundary conditions for RHS of y-dimension
\item \var{z\_boundary\_lhs} : Boundary conditions for LHS of z-dimension
\item \var{z\_boundary\_rhs} : Boundary conditions for RHS of z-dimension
For all boundaries: \\
\begin{tabular}{ll}
open     & = open boundaries (i.e. extends to infinity) \\
periodic & = periodic wrapping between LHS \& RHS boundary \\
wall     & = wall at boundary (i.e. reflection of particles)
%mirror   & = mirror boundary (i.e. 'ghost' reflections)
\end{tabular}

\item \var{boxmin[0]} : Location of LHS x-boundary
\item \var{boxmax[0]} : Location of RHS x-boundary
\item \var{boxmin[1]} : Location of LHS y-boundary
\item \var{boxmax[1]} : Location of RHS y-boundary
\item \var{boxmin[2]} : Location of LHS z-boundary
\item \var{boxmax[2]} : Location of RHS z-boundary


\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Initial conditions parameters}

\begin{itemize}

\item \var{smooth\_ic} : Smooth any particle quantities around discontinuities

\item \var{com\_frame} : Translatr ICs to COM frame before starting simulation

\item \var{Nsph} : No. of SPH particles
\item \var{Nstar} : No. of star particles

\item \var{Nlattice1[0]} : No. of ptcls on lattice 1 in x-dimension
\item \var{Nlattice1[1]} : No. of ptcls on lattice 1 in y-dimension
\item \var{Nlattice1[2]} : No. of ptcls on lattice 1 in z-dimension
\item \var{Nlattice2[0]} : No. of ptcls on lattice 2 in x-dimension
\item \var{Nlattice2[1]} : No. of ptcls on lattice 2 in y-dimension
\item \var{Nlattice2[2]} : No. of ptcls on lattice 2 in z-dimension

\item \var{vfluid1[0]}   : x-velocity of fluid 1
\item \var{vfluid1[1]}   : y-velocity of fluid 1
\item \var{vfluid1[2]}   : z-velocity of fluid 1
\item \var{vfluid2[0]}   : x-velocity of fluid 2
\item \var{vfluid2[1]}   : y-velocity of fluid 2
\item \var{vfluid2[2]}   : z-velocity of fluid 2

\item \var{rhofluid1}    : Density of fluid 1
\item \var{rhofluid2}    : Density of fluid 2

\item \var{press1}       : Pressure of fluid 1
\item \var{press2}       : Pressure of fluid 2

\item \var{amp}          : Amplitude of applied perturbation
\item \var{lambda}       : Wavelength of applied perturbation

\item \var{kefrac}       : Fraction of energy that is kinetic (Sedov test)
\item \var{radius}       : Radius of cloud
\item \var{angvel}       : Angular velocity of cloud (in radians per second)
\item \var{mcloud}       : Mass of cloud

\item \var{rplummer}     : Plummer radius
\item \var{mplummer}     : Total mass of plummer sphere

\item \var{rstar}        : (Softening) radius of star particles

%\item \var{cdmfrac}   : Fraction of mass in cdm particles
\item \var{gasfrac}      : Fraction of mass in gas particles
\item \var{starfrac}     : Fraction of mass in star particles

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python viewer parameters}

\begin{itemize}

\item \var{dt\_python} : Time interval (in seconds) between view window updates

\end{itemize}


\newpage




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generating initial conditions}

One important difference between SEREN and GANDALF is that initial conditions can be generated on-the-fly in GANDALF, i.e. while running the code, unlike SEREN where initial conditions always had to be generated before the simulation.  While they are still situations where it is appropriate to prepare initial conditions prior to running the simulations, it is more convenient to generate the initial conditions at the same time as running the simulation. It's also possible to generate the initial conditions in python (see next section).

At present, the following initial conditions are included in the code : \newline

\noindent SPH simulations : \\
\begin{tabular}{ll}
- box       &: Create uniform box \\
- khi       &: Kelvin-helmholtz instability \\
- plummer   &: Plummer sphere (stars + gas, or just gas) \\
- rti       &: Rayleigh-Taylor instability \\
- sedov     &: Sedov blastwave test \\
- shocktube &: Simple two-fluid shocktube test \\
- sphere    &: Create uniform density sphere
\end{tabular}
\newline

\noindent N-body simultions : \\
\begin{tabular}{ll}
- binary    &: Simple circular binary test \\
- burrau    &: Burrau Pythagorean test \\
- figure8   &: Simple 3-body figure-8 test \\
- plummer   &: Plummer sphere (stars + gas, or just stars) \\
- quadruple &: Simple hierarchical quadruple test
\end{tabular}

\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GANDALF Python library} \label{S:PYTHONSCRIPT}

The GANDALF Python library can be used for many purposes, 
\begin{itemize}
\item To load in previously run simulations for analysis and producing visualisation
\item To load in multiple previously run simulations for comparisons
\item To prepare often-run simulations including the analysis in a single script 
\item To run batches of simulations (e.g. a parameter study) with a single controlling script
\item To run or analyse simulations interactively through the interpreter
\item To generate initial conditions directly in python (instead of via a file or in C++) and run the simulation
\end{itemize}
It can therefore provide an easier entry into using SPH and N-body than other codes which require more investigation of the code mechanics and file formats before even basic simulations can be run.

%While the numerical part of GANDALF  is implemented in C++ for efficiency, we provide bindings to Python to control the simulation and a large set of analysis and plotting tools to inspect the results. Therefore, from Python you are able to set up the simulation (including initial conditions), run it, load existing snapshots and plot quantities. 

There are two main ways to use the Python side of GANDALF; (a) a python script, and  (b) the interpreter, that works similarly to a shell (e.g. bash, csh).  Both methods understand a specific set of commands to load a simulation and plot quantities, although in principle using a Python script is more powerful %We provide a large set of commands to do standard operations when running and analyzing a simulation, so that this solution can be satisfactory where you need to quickly analyze a simulation.
% The second way is writing your own python script. You still have access to the same commands available in the interpeter, but combining the power of the python language you are free to do much more. 
since you can access the raw particle data (via swig) and compute additional particle properties.  The Python files for both the library and the interpreter and contained in the \var{gandalf/analysis} sub-directory.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python script usage}
The GANDALF Python library contains a number of modules that can be imported in to provide the desired functionality.  
\begin{itemize}
\item \var{gandalf.analysis.facade} \\
\noindent This module is the main front-end to the GANDALF Python library and contains the Python-wrapped C++ executable and all functions required to set-up and run simulations.  This module must always be imported in GANDALF Python scripts.
\item \var{gandalf.analysis.compute} \\
\noindent This module contains all extra and user-defined routines for computing important quantities from the simulation snapshot data.  Currently contains routines for computing centre-of-mass properties, L1 error norm (when provided with an analytical solution) and the Lagrangian radius.
\item \var{gandalf.analysis.data\_fetcher} \\
This module contains routines for exporting data from the C++ code to Python, generating custom data (e.g. time evolution) from snapshot data and generating user-defined data quantities from raw particle data.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interpreter usage}

%The interpreter is located in the analysis/ folder in the main directory of GANDALF. 
To start the interpreter, type \\
\newline
\noindent \var{python analysis/gandalf\_interpreter.py}. \\
\newline
A list of commands available for the python interpeter can be printed by typing the 'help' command.  Furthermore, typing 'help command' gives more information on the chosen command.  The commands in the interpreter are principally the same as those used in the script.  The main difference is the scripts call functions with arguments in parenthesis serparated by commas, whereas the interpreter works like a command-line tool with arguments separated by spaces.  For example, the plot command in the python script will appear like \var{plot(`x',`y')} whereas the interpreter equivalent would be typed as \var{plot x y}.


%Like in a shell, you can use the interpreter interactively or you can write little scripts for it (that is, texts files with a list of the commands that you want to be executed). \textbf{TODO: must actually implement reading from a script}. Any script can be read in and processed by typing : \var{read SCRIPTNAME}.

%The interpreter provides commands for creating new simulations, loading a simulation and do the plotting. The next section contains some examples to show how to use it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Commands}
To be done



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Python interpreter examples}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Write your Python script}

%All the commands available in the interpreter can also be used in your Python script. Just note the slight difference in syntax (since they are function, you need to put the arguments inside parentheses and they must be comma-separated). To use them, you need to import the module facade.py in the analysis/ folder. We recommend to add it to your PYTHONPATH to make the import simpler. Each function in facade comes with documentation, so you can inspect that to know what a function does.

%Here are the same examples from the previous section, rewritten to show how to use them in a Python script:
%\textbf{add examples}

%In addition, in your script you can also perform other tasks that are not possible from the interpreter, since you have a full programming language at your disposal. For example:
%\begin{itemize}

%\item You can modify from Python the parameters of the simulation before running it. This is very useful to do parameter studies, without generating in advance many different parameter files. Just remember to change the run\_id for each one of the simulations that you want to run, otherwise all the snapshots will be overwritten.

%\textbf{Example}

%\item It is possible to generate the initial conditions from Python. You need to create numpy arrays containing the quantities for the SPH particles (position, velocity, mass, internal energy) and you can import them in the code. An example follows:
%\textbf{Write the example!}

%\item You can define your own quantities to add to the plots in addition to the built-in ones. \textbf{Not implemented yet}

%\item It is possible to get access to the raw data of the simulation, in order to compute whatever quantity you need. \textbf{Actually, this is not possible yet in an easy way... I need to write a proper wrapper around the C++ method which is too low level. Remember -> give 'snap' attribute to the array to save reference counting. Implement it!}

%\item Everything else that you can think. The point is, it's GANDALF that takes care of reading the snapshots, getting the data, and all this boring parts; you can concentrate on what to do with the data and on the science, and forget about the details.

%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Structure of the python code}

%If you just want to use the python code, the previous section is enough. But if you want to develop some new feature, or you are just curious to know how we implemented it, you can go on reading.

%The functions defined in facade act mostly as wrappers around lower levels of abstraction. Sometimes they also make two different portions of the code communicate. The three main lower-level portions of the code are:
%\begin{itemize}

%\item SimBuffer. This class is responsible to keep track of all the simulations you have loaded, and the snapshots that are available for each one of them, either on disk or in memory (if you are running it). To eliminate the overhead of reading from the disk as much as possible (which is particularly important with network mounted filesystems), data is cached in memory once read. When all the cache is used, the buffer will look for objects that are no longer used since a long time and deallocate them to make space. The algorithm used is LRU (least recently used), which unfortunately is not scan resistant. However, we think that scans along all the snapshots are not something frequently enough to be a problem. The size in memory of the cache is a parameter that you can set; by default it is 1 GB. \textbf{Give to the user the possibility to change it}. Always use the functions in the buffer when you want to have the raw simulation/snapshot object, rather than reading them manually; in addition to saving you a lot of coding, this ensures that you are using caching and speeding up the reading.

%\item Plotting process. In order to have the figures responsive while the simulation is running, the plotting part is done in another process. A queue is used to make the main process (the one that responds to the user commands, and where the simulation runs) communicate with the plotting one. Two kinds of objects are transferred by this queue: the data to plot, and the commands to execute (see next element). The plotting process executes a loop: it reads what is there in the queue, and executes the commands if there is any. Then sleeps for a while, letting the user interact with the plots.

%There is a potential performance improvement in the transferring of the data along the queue. Internally, python uses the pickle module to serialize the array, which is quite slow. Using zeromq, it would be possible to copy the binary data, which would be just a memcopy and therefore very fast compared to the plotting itself. Another possible improvement is to store the data used, and avoid transferring it again each time a plot is updated.

%\item Commands. The functions in facade that interact with the plotting process create a command object and send them through the queue. A command is a class that contains a method that gets called by the plotting process when the object is received. Therefore, it's the command itself that knows what to do when it's called, rather than the plotting process. This separates the roles of the plotting process from the ones of the commands. Some of the commands also contain methods for getting the data from the simulation (this happens in the main process, where the data is stored).


%\end{itemize}

\newpage 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python script examples}


{\bf Example 1 - Creating and running a new simulation from a parameter file} \\
\newline
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{sim = newsim(`params.dat')}           & Create a new simulation object \\
                                           & directly from given parameters file \\
\var{setupsim()}                           & call all set-up routines \\
\var{run()}                                & Run simulation
\end{tabular}
\vspace{1cm}

\noindent {\bf Example 2 - Creating a simulation from a parameters file and modifying a parameter before running} \\
\newline
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{sim = newsim(`params.dat')}           & Create a new simulation object directly from given parameters file \\
\var{sim.SetParam('tend',2.0)}              & Modify parameters \\
\var{setupsim()}                           & Run set-up routines after parameters have been modifed (N.B. modifying parameters after this step has no effect) \\
\var{run()}                                & Run simulation
\end{tabular}
\vspace{1cm}

\noindent {\bf Example 3 - Creating and running a new simulation using the internal initial conditions routines without a parameters file} \\
\newline
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{sim = newsim(ndim=2)}                 & Create a new (but unspecified) 2D simulation object \\
\var{sim.SetParam(`sim',`sph')}            & Create SPH simulation \\
\var{sim.SetParam(`sph',`gradh')}          & Use grad-h SPH algorithm \\
\var{sim.SetParam(`ic',`sedov')}           & Set initial conditions routine (Sedov blast wave) \\
\var{sim.SetParam(`Nlattice[0]',64)}       & Create 64 by 64 cube of particles \\
\var{sim.SetParam(`Nlattice[1]',64)}       & \\
\var{sim.SetParam(`tend',0.5)}             & Set simulation run-time \\
\var{setupsim()}                           & Now all parameters have been set, call set-up routines \\
\var{run()}                                & Run simulation
\end{tabular}
\vspace{1cm}

\noindent{\bf Example 4 - Running a simulation and plotting results to screen and file} \\
\newline
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{sim = newsim(`params.dat')}           & Create a new simulation object \\
                                           & directly from given parameters file \\
\var{setupsim()}                           & Run all set-up routines \\
\var{plot(`x',`y')}                        & Open window and plot all particle x-y positions \\
\var{run()}                                & Run simulation \\
\var{savefig(`figure.eps')}                & Save plot to eps file
\end{tabular}
\vspace{1cm}

\noindent{\bf Example 5 - Reading a simulation from disc and plotting several snapshots} \\
\newline
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{loadsim('TEST1')}                     & Create a new simulation object by reading all data snapshots from simulation \var{TEST1} \\
\var{plot(`x',`y',snap=0)}                 & Open window and plot all particle x-y positions for first snapshot (N.B. snapshot numbers start from 0) \\
\var{savefig(`snap1.eps')}                 & Save plot to eps file \\
\var{plot(`x',`y',snap=1)}                 & Plot x-y positions for second snapshot \\
\var{savefig(`snap2.eps')}                 & Save second snapshot to eps file \\
\var{plot(`x',`y',snap=0)}                 & Plot both snapshot 0 and 1 on the \\
\var{addplot(`x',`y',snap=1)}              & same window. \\
\var{savefig(`snap12.eps')}                & Save combined data to eps file
\end{tabular}
\vspace{1cm}

\newpage

\noindent{\bf Example 6 - Create a shock-tube simualtion directly in a python script} \\
\begin{tabular}{p{8.0cm}p{7.0cm}}
\var{from gandalf.analysis.facade import *}& Import code python library \\
\var{import numpy as np}                   & and other libraries \\
\var{import time}                          & \\
& \\
\var{sim = newsim(ndim=1)}                 & Create a new (but unspecified) 1D simulation object \\
& \\                                       
\var{sim.SetParam('ic','python')}          & Initial conditions will be set in python script  \\
\var{sim.SetParam('sph','gradh')}          & Use conservative 'grad-h' SPH \\
\var{sim.SetParam('sph\_integration','lfkdk')} & Use leapfrog-KDK integrator for SPH \\
\var{sim.SetParam('gas\_eos','energy\_eqn')} & Integrate energy equation \\
\var{sim.SetParam('energy\_integration','PEC')} & Use Predict-correct-evaluate energy integration \\
\var{sim.SetParam('gamma\_eos',1.6666666666)} & gamma = 5/3\\
\var{sim.SetParam('Nsph',200)} & 200 SPH particles \\
\var{sim.SetParam('tend',0.075)} & \\
\var{sim.SetParam('dt\_snap',1.0)} & \\
\var{sim.SetParam('x\_boundary\_lhs','open')} & Use open/free boundaries\\
\var{sim.SetParam('x\_boundary\_rhs','open')} & \\
& \\                      
\var{Npart = 200} &  Set number of particles \\
\var{x = np.linspace(-0.995,0.995,num=Npart)} & Create regularly spaced particles \\
\var{vx = np.zeros(Nsph)}  & \\
\var{m = np.ones(Nsph)*2.0/Nsph} & \\
\var{u = np.ones(Nsph)*1.5} & \\
& \\          
\var{for i in range(Nsph):}   & Loop over all particles \\
\hspace{0.5cm}\var{if x[i] < 0.0:}   & Set velocity depending on whether particle \\
\hspace{1cm}\var{vx[i] = 4.0}   & is in LHS or RHS shock region \\
\hspace{0.5cm}\var{else:} & \\
\hspace{1cm}\var{vx[i] = -4.0} & \\
& \\  
\var{sim.PreSetupForPython()}  & Now call setup routines to create objects and allocate memory 
(N.B. parameters are now fixed and cannot be changed after this point) \\
\var{sim.ImportArray(x,'x')}    & Import all arrays to main memory \\
\var{sim.ImportArray(vx,'vx')}  & \\
\var{sim.ImportArray(m,'m')}    & \\
\var{sim.ImportArray(u,'u')}    & \\
\var{sim.SetupSimulation()}     & Finally perform all setup routines in C++ code\\
& \\                                  
\var{plot("x","rho")}           & First, plot the initial conditions \\ 
& \\              
\var{run()}                     & Run simulations \\
\var{plot("x","rho")}           & Re-plot results \\
\var{block()}                   & Pause program to prevent window closing \\
\end{tabular}
\newline


\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{To-do list}

\subsection{Known bugs}
List of known bugs as of version \VERNO.

\begin{itemize}
\item Neighbour timestep limiter (Saitoh \& Makino 20??) does not work correctly with OpenMP activated at present.
%\item If running a simulation in interactive mode, the simulation variables can become corrupted if previous snapshots are viewed, i.e. once a previous snapshot is viewed, the simulation can no longer be continued.
%\item If running a simulation in interactive mode and a different simulation is loaded into memory, then it is no longer possible to continue running that simulation.
%\item Rendered images are technically not done correct if smoothing lengths are smaller than the grid size (which can often be the case, although the images are fine for viewing/movie purposes).
\end{itemize}


\subsection{Proposed features}
List of possible new features for future versions.

\begin{itemize}
\item Allow ability to add titles to graphs in matplotlib
\item Include analytical solutions for Sedov blast-wave test and freefall collapse test
\item Plot star/sink-based statistics, e.g. sink mass-functions, binary statistics
\item More sanity-checking, error-trapping and assert statements (to prevent crashing on erroneous input and to help debugging purposes).
\end{itemize}


\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%